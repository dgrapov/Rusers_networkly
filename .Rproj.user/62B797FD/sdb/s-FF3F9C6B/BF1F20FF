{
    "collab_server" : "",
    "contents" : "\n\n#' @title get_edges\n#' @export\nget_edges<-function(obj,color=\"color\",width=\"size\",name=\"names\",type=\"2d\",...){\n\n  #set net opts\n  if(type == \"2d\"){\n    opts<-list(mode=\"lines\",type=\"scatter\",...)\n  } else {\n    opts<-list(mode=\"lines\",type=\"scatter3d\",...)\n  }\n  #split list for element mapping (could be done together?)\n  # mappings<-obj$edges[,c(color,width),drop=FALSE]\n  segs<-rep(1:(nrow(obj$edges)/2),each=2)\n  # if(!is.null(mappings)){\n  #   id<-lapply(1:nrow(mappings),function(i){\n  #     paste(paste(mappings[i,],collapse=\"_\"),segs[i])\n  #   })\n  #   id<-unlist(id)\n  #   el<-split(obj$edges,id)\n  #\n  # } else {\n    el<-split(obj$edges,segs) # split all\n  # }\n\n  #need to split into induvidual segments, for 3d and size maping to work\n\n\n  #generate elements\n  res<-list()\n  for (i in 1:length(el)){\n    tmp<-el[[i]]\n    res[[i]]<-c(list(x=tmp$x,\n                     y=tmp$y,\n                     z=tmp$z,\n                     name = tryCatch(tmp[,name][1],error=function(e){NULL}), # TODO: fix hack\n                     line=list(\n                       color = ifelse(is.null(rgb_col(tmp[,color])[1]),rgb_col(\"gray\"),rgb_col(tmp[,color])[1]),\n                       width = tryCatch(as.numeric(as.character(tmp[,width][1])),error=function(e){5})) # why is this a factor?\n    ),opts)\n  }\n  return(res)\n}\n\n#' @title get_nodes\n#' @export\n#' @import dplyr\nget_nodes<-function(obj,node.data=NULL,color=\"color\",size=\"size\",name=\"names\",type=\"2d\",merge=TRUE,...){\n  if(!is.null(node.data) & merge){\n    #merge with nodes based on rowname\n    node.data<-cbind(obj$nodes,node.data[rownames(obj$nodes),])\n  }\n  #set net opts\n  if(type == \"2d\"){\n    opts<-list(mode=\"markers\",type=\"scatter\",...)\n  } else {\n    opts<-list(mode=\"markers\",type=\"scatter3d\",...)\n  }\n  #split list for element mapping (could be done together?)\n  mappings<-node.data[,c(color,size,name),drop=FALSE]\n  if(!is.null(mappings)){\n    id<-lapply(1:nrow(mappings),function(i){\n      paste(mappings[i,],collapse=\"_\")\n    })\n    id<-unlist(id)\n    node.data<-split(node.data,id)\n  } else {\n    node.data<-list(node.data)\n  }\n\n  #generate elements\n  res<-list()\n  for (i in 1:length(node.data)){\n    tmp<-node.data[[i]]\n    res[[i]]<-c(list(x=tmp$x,\n                     y=tmp$y,\n                     z=tmp$z,\n                     name = unique(tmp[,name]),\n                     marker=list(\n                       color = unique(rgb_col(tmp[,color])),\n                       size = unique(tmp[,size]))\n    ),opts)\n  }\n  return(res)\n}\n\n\n#' @title get_text\n#' @export\nget_text<-function(obj,node.data,text='names',extra=NULL,type=\"2d\",xoff=0,yoff=0,zoff=0,...){\n  if(!is.null(node.data)){\n    #merge with nodes based on rowname\n    node.data<-cbind(obj$nodes,node.data[rownames(obj$nodes),])\n  }\n  #set net opts\n  if(type == \"2d\"){\n    opts<-list(mode=\"text\",type=\"scatter\",...)\n  } else {\n    opts<-list(mode=\"text\",type=\"scatter3d\",...)\n  }\n\n  #split list for element mapping (could be done together?)\n  res<-c(list(x=node.data$x + get_unit(node.data$x, xoff),\n              y=node.data$y + get_unit(node.data$y, yoff),\n              z=node.data$z + get_unit(node.data$z, zoff),\n              text = node.data[,text])\n         ,opts,extra)\n\n  return(list(res))\n}\n\n#' @title make_edges\n#' @export\nmake_edges<-function(whichRow,layout,adjacency,type=\"2d\"){\n  fromC <- layout[adjacency[whichRow, 1], ]\n  toC <- layout[adjacency[whichRow, 2], ]\n  if(type == \"2d\") {\n    edge <- data.frame(c(fromC[1], toC[1]), c(fromC[2] ,toC[2]))\n    colnames(edge)<-c(\"x\",\"y\")\n  } else {\n    edge <- data.frame(c(fromC[1], toC[1]), c(fromC[2] ,toC[2]), c(fromC[3] ,toC[3]))\n    colnames(edge)<-c(\"x\",\"y\",\"z\")\n  }\n\n  if(ncol(adjacency)>2){\n    tmp<-data.frame(matrix(as.matrix(adjacency[whichRow, -c(1,2),drop=FALSE]),nrow = nrow(edge), ncol=ncol(adjacency)-2, byrow=TRUE))\n    colnames(tmp)<-colnames(adjacency)[-c(1:2)]\n    edge$extra<-tmp\n    edge<-do.call(\"cbind\",edge)\n    colnames(edge)<-gsub(\"extra.\",\"\",colnames(edge))\n  }\n  edge$fromID<-adjacency[whichRow, 1]\n  edge$toID<-adjacency[whichRow, 2]\n  return(edge)\n}\n\n#' @title get_network\n#' @export\n#' @import network sna\nget_network<-function(edge.list,type=\"2d\",layout=\"fruchtermanreingold\", layout.par=NULL){\n\n  #source target assumed first\n  rev.edge.list<-edge.list[,1:2,drop=FALSE]\n\n  #extra info (separate now, later recombine)\n  info<-edge.list[,-c(1:2),drop=FALSE]\n\n  #getting layout and making sure edge list ids are in the same order\n  g<-as.network(rev.edge.list[,1:2],matrix.type = \"edgelist\") #\n  if (type== \"2d\") {\n    layout<-switch(layout,\n                   \"adj\" = gplot.layout.adj(g[,], layout.par),\n                   \"circle\" =  gplot.layout.circle(g[,], layout.par),\n                   \"circrand\" =  gplot.layout.circrand(g[,], layout.par),\n                   \"eigen\" =  gplot.layout.eigen(g[,], layout.par),\n                   \"fruchtermanreingold\" =  gplot.layout.fruchtermanreingold(g[,], layout.par),\n                   \"geodist\" =  gplot.layout.geodist(g[,], layout.par),\n                   \"hall\" =  gplot.layout.hall(g[,], layout.par),\n                   \"kamadakawai\" =  gplot.layout.kamadakawai(g[,], layout.par),\n                   \"mds\" =  gplot.layout.mds(g[,], layout.par),\n                   \"princoord\" =  gplot.layout.princoord(g[,], layout.par),\n                   \"random\" =  gplot.layout.random(g[,], layout.par),\n                   \"rmds\" =  gplot.layout.rmds(g[,], layout.par),\n                   \"segeo\" =  gplot.layout.segeo(g[,], layout.par),\n                   \"seham\" =  gplot.layout.seham(g[,], layout.par),\n                   \"spring\" =  gplot.layout.spring(g[,], layout.par),\n                   \"springrepulse\" =  gplot.layout.springrepulse(g[,], layout.par),\n                   \"target\" =  gplot.layout.target(g[,], layout.par)\n    )\n\n    #back to edgelist\n    n.edge.list<-as.matrix.network.edgelist(g)\n    #match layout with nodes\n    dimnames(layout)<-list(rownames(g[,]),c(\"x\",\"y\"))\n\n  } else {\n    layout<-switch(layout,\n                   \"adj\" =  gplot3d.layout.adj(g[,], layout.par),\n                   \"eigen\" =  gplot3d.layout.eigen(g[,], layout.par),\n                   \"fruchtermanreingold\" = gplot3d.layout.fruchtermanreingold(g[,], layout.par),\n                   \"geodist\" = gplot3d.layout.geodist(g[,], layout.par),\n                   \"hall\" = gplot3d.layout.hall(g[,], layout.par),\n                   \"kamadakawai\" = gplot3d.layout.kamadakawai(g[,], layout.par),\n                   \"mds\" = gplot3d.layout.mds(g[,], layout.par),\n                   \"princoord\" = gplot3d.layout.princoord(g[,], layout.par),\n                   \"random\" = gplot3d.layout.random(g[,], layout.par),\n                   \"rmds\" = gplot3d.layout.rmds(g[,], layout.par),\n                   \"segeo\" = gplot3d.layout.segeo(g[,], layout.par),\n                   \"seham\" = gplot3d.layout.seham(g[,], layout.par)\n    )\n\n    #back to edgelist\n    n.edge.list<-as.matrix.network.edgelist(g)\n    #match layout with nodes\n    dimnames(layout)<-list(rownames(g[,]),c(\"x\",\"y\",\"z\"))\n  }\n\n\n  #preparing for edge path\n  adjacency<-data.frame(n.edge.list,info)\n\n  #create edge positions\n  #TODO make parallel\n  allEdges <- lapply(1:nrow(adjacency),function(i){\n    make_edges(i,layout,adjacency,type=type)\n  })\n  list(nodes = data.frame(layout), edges=data.frame(do.call(rbind, allEdges)))\n}\n\n#' @title format_legend\n#' @export\n#' @import dplyr\nformat_legend<-function(obj,edges=TRUE,nodes=TRUE,width='size',color='color',size='size',name='names',node.data){\n\n  res<-list()\n  #edges\n  if(edges){\n    el<-obj$edges\n    vars<-c(width,color,name)\n    id<-el %>% select(one_of(vars)) %>% apply(.,1,paste,collapse=\"|\")\n    tmp<-el[!duplicated(id),]\n    tmp$x<-tmp$y<-tmp$z<-NA\n    res$edges<-tmp\n  }\n  #nodes\n  if(nodes){\n    el<-cbind(obj$nodes,node.data)\n    vars<-c(size,color,name)\n    id<-el %>% select(one_of(vars)) %>% apply(.,1,paste,collapse=\"|\")\n    tmp<-el[!duplicated(id),]\n    tmp$x<-tmp$y<-tmp$z<-NA\n    res$nodes<-tmp[,c(\"x\",\"y\",\"z\")]\n    res$node.data<-tmp\n  }\n  return(res)\n}\n\n\n\n#' @title list_ggplotly\n#' @import plotly\nlist_ggplotly<-function (l, filename, fileopt, world_readable = TRUE)\n{\n  if (!missing(filename))\n    l$filename <- filename\n  if (!missing(fileopt))\n    l$fileopt <- fileopt\n  l$world_readable <- world_readable\n  plotly:::hash_plot(df=NULL, l)\n}\n\n#' @title add_struct\n#' @import plotly\nadd_struct<-function(obj){\n  l <- list(data = obj)\n  structure(plotly:::add_boxed(plotly:::rm_asis(l)), class = \"plotly\")\n}\n\n#' @title shiny_ly\n#' @import plotly\n#' @export\nshiny_ly<-function (obj)\n{\n  net<-add_struct(obj)\n  net <- plotly:::plotly_build(net)\n  plotly:::hash_plot(df=NULL, net)\n}\n\n\n#accesory fxns\n\n#' @title rgb_col\n#' @import grDevices\nrgb_col<-function(col){\n  lapply(col,function(x){\n    rgb<-col2rgb(x, alpha = FALSE)[,1]\n    paste0('rgb(',paste(rgb,collapse=\",\"),\")\",collapse=\"\")\n  }) %>% unlist()\n}\n\n#' @title line_brk\nline_brk<-function(obj){\n  paste0(lapply(obj,function(x) {paste(x,collapse=\"\")}),collapse=\"<br>\")\n}\n\n\n#' @title get_unit\nget_unit<-function(x,prct=10){\n  rng<-diff(range(x))*(prct/100)\n}\n\n\n#' @title test\ntest<-function(){\nlibrary(plotly)\nlibrary(networkly)\nconn<-1\nnodes<-10\nnet_size<-conn*nodes\nedge_type<-2\nlayout<-\"fruchtermanreingold\"\n\n#color/size\nset.seed(555)\nid<-factor(sample(1:edge_type,net_size,replace = TRUE))\nid2<-factor(sample(1:10,nodes,replace = TRUE))\n\nedge.list<-data.frame(source=sample(1:nodes,net_size,replace=TRUE),\n                      target=sample(1:nodes,net_size,replace=TRUE),\n                      color=rainbow(edge_type)[id],\n                      size=sample(seq(1,10,length.out=10),edge_type,replace=TRUE)[id],\n                      names=letters[id],stringsAsFactors = FALSE)\nnode.data<-data.frame(color=sample(rainbow(10),nodes,replace=TRUE)[id2],\n                      size=sample(seq(10,50,length.out=10),nodes,replace=TRUE)[id2],\n                      names=sample(LETTERS[1:5],nodes,replace=TRUE)[id2],stringsAsFactors = FALSE)\n\n\n\n#net params\ntype<-\"2d\"\ncolor<-'color'\nsize<-'size'\nname<-'names'\nobj<-get_network(edge.list,type=type,layout=layout)\nnet<-c(get_edges(obj,color=color,width=size,name=name,type=type,hoverinfo=\"none\",showlegend=FALSE),\n       get_nodes(obj,node.data,color=color,size=size,name=name,type=type,hoverinfo=\"name\",showlegend=FALSE),\n       get_text(obj,node.data,text=name,extra=list(textfont=list(size=40)),type=type,yoff=-10,hoverinfo=\"none\",showlegend=FALSE))\n\n\nlegend<-format_legend(obj,node.data=node.data)\n\nnet2<-c(net,c(get_edges(legend,color=color,width=size,name=name,type=type,hoverinfo=\"none\",showlegend=TRUE),get_nodes(legend,node.data=legend$node.data,color=color,size=size,name=name,type=type,hoverinfo=\"name\",showlegend=TRUE)))\n\n\nnet<-shiny_ly(net) # works in or out of shiny\nnet<-shiny_ly(net2) # with legend?\n\nif(type==\"2d\"){\n  layout(net,\n         xaxis = list(title = \"\", showgrid = FALSE, showticklabels = FALSE, zeroline = FALSE, hoverformat = '.2f'),\n         yaxis = list(title = \"\", showgrid = FALSE, showticklabels = FALSE, zeroline = FALSE, hoverformat = '.2f'))\n\n} else{\n  layout(net,\n         scene = list(showlegend=TRUE,\n                      yaxis=list(showgrid=FALSE,showticklabels=FALSE,zeroline=FALSE,title=\"\"),\n                      xaxis=list(showgrid=FALSE,showticklabels=FALSE,zeroline=FALSE,title=\"\"),\n                      zaxis=list(showgrid=FALSE,showticklabels=FALSE,zeroline=FALSE,title=\"\")))\n}\n\n}\n",
    "created" : 1458611255120.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1957110519",
    "id" : "BF1F20FF",
    "lastKnownWriteTime" : 1458687782,
    "last_content_update" : 1458687782,
    "path" : "C:/Users/Dmitry/Dropbox/Software/networkly/R/plotly_network.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}